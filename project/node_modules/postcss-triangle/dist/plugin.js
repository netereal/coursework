"use strict";
const postcss = require("postcss");
const plugin = 'postcss-triangle';
const errorContext = { plugin };
const oppositeDirectionMap = {
    up: 'bottom',
    right: 'left',
    down: 'top',
    left: 'right'
};
const PostCssTriangle = postcss.plugin(plugin, (options = {}) => {
    if (typeof options.unitPrecision === 'undefined') {
        options.unitPrecision = 5;
    }
    return root => {
        root.walkRules(rule => {
            let isTriangle = false;
            let width;
            let height;
            let direction;
            rule.walkDecls('triangle', decl => {
                isTriangle = true;
                let wd;
                rule.walkDecls('width', d => {
                    wd = d;
                });
                if (wd) {
                    width = parseLength(wd.value);
                    wd.value = '0';
                    decl.before(wd.remove());
                }
                else {
                    decl.cloneBefore({ prop: 'width', value: '0' });
                }
                let hd;
                rule.walkDecls('height', d => {
                    hd = d;
                });
                if (hd) {
                    height = parseLength(hd.value);
                    hd.value = '0';
                    decl.before(hd.remove());
                }
                else {
                    decl.cloneBefore({ prop: 'height', value: '0' });
                }
                decl.cloneBefore({
                    prop: 'border-style',
                    value: 'solid'
                });
                decl.cloneBefore({
                    prop: 'border-color',
                    value: 'transparent'
                });
                let type;
                [type, direction] = postcss.list.space(decl.value);
                if (!direction) {
                    direction = type;
                    if (!width) {
                        throw rule.error(`Missing required width declaration`, errorContext);
                    }
                    if (!height) {
                        throw rule.error(`Missing required height declaration`, errorContext);
                    }
                }
                else if (!/^(right-iso|equilateral)$/.test(type)) {
                    throw decl.error(`Unsupported type: ${type}`, errorContext);
                }
                else if (!width && !height) {
                    throw rule.error(`Missing required width or height declaration`, errorContext);
                }
                else if (width && height) {
                    throw rule.error(`${type} triangle cannot have both width and height`, errorContext);
                }
                else {
                    const multiplier = type === 'right-iso' ? 0.5 : sinDegrees(60);
                    if (/^(pointing-(up|down))$/.test(direction)) {
                        width = width || {
                            value: height.value / multiplier,
                            unit: height.unit
                        };
                        height = height || {
                            value: width.value * multiplier,
                            unit: width.unit
                        };
                    }
                    else {
                        width = width || {
                            value: height.value * multiplier,
                            unit: height.unit
                        };
                        height = height || {
                            value: width.value / multiplier,
                            unit: width.unit
                        };
                    }
                }
                if (!/^(pointing-(up|down|left|right))$/.test(direction)) {
                    throw decl.error(`Unsupported direction: ${direction}.`, errorContext);
                }
                decl.cloneBefore({
                    prop: 'border-width',
                    value: buildBorderWidth(width, height, direction)
                });
                decl.remove();
            });
            if (!isTriangle) {
                return;
            }
            let isColorDefined = false;
            rule.walkDecls('background-color', decl => {
                isColorDefined = true;
                const oppositeDirection = oppositeDirectionMap[direction.split('-')[1]];
                decl.prop = `border-${oppositeDirection}-color`;
            });
            if (!isColorDefined) {
                throw rule.error(`Missing required background-color declaration`, errorContext);
            }
        });
    };
    function sinDegrees(angle) {
        return Math.sin(angle / 180 * Math.PI);
    }
    function parseLength(length) {
        const value = parseFloat(length);
        const [, unit] = length.match(/([a-z]+)$/);
        return { value, unit };
    }
    function stringifyLength(length) {
        const precision = Math.pow(10, options.unitPrecision);
        const rounded = Math.round(length.value * precision) / precision;
        return rounded + length.unit;
    }
    function buildBorderWidth(width, height, direction) {
        const hw = stringifyLength({
            value: width.value / 2,
            unit: width.unit
        });
        const hh = stringifyLength({
            value: height.value / 2,
            unit: height.unit
        });
        const w = stringifyLength(width);
        const h = stringifyLength(height);
        const resultMap = {
            up: `0 ${hw} ${h}`,
            right: `${hh} 0 ${hh} ${w}`,
            down: `${h} ${hw} 0`,
            left: `${hh} ${w} ${hh} 0`
        };
        return resultMap[direction.split('-')[1]];
    }
});
module.exports = PostCssTriangle;
//# sourceMappingURL=plugin.js.map